# BlockChain - SBU 2022

## Codes:
- [ColoredWallet Smart Contract Code](ColoredWalletSolution.sol)

## Transactions
- [Etherscan](https://goerli.etherscan.io/tx/0xd281cf70de4e595dab1721af31af730f313137666f7285e921b392a3c49a2da6)

## Answers
- view VS pure:

    In Solidity, the pure and view functions are two types of functions that have special properties when it comes to reading and writing to the blockchain.

    pure functions are functions that do not modify the state of the contract and do not interact with the blockchain in any way. They are called "pure" because they always return the same result for the same input, and they do not have any side effects. pure functions are typically used for simple calculations or for checking the values of contract variables.

    view functions are similar to pure functions in that they do not modify the state of the contract or interact with the blockchain. However, unlike pure functions, view functions are allowed to read the state of the contract and access contract variables. They are called "view" functions because they do not modify the state of the contract and only "view" the current state.

    Here is an example of a pure function and a view function in Solidity:

    ```solidity
    pragma solidity ^0.6.0;

    contract MyContract {
        uint public balance;

        function add(uint a, uint b) public pure returns (uint) {
            return a + b;
        }

        function getBalance() public view returns (uint) {
            return balance;
        }
    }
    ```
    In this example, the add function is a pure function because it does not modify the state of the contract or interact with the blockchain. It simply adds two numbers and returns the result. The getBalance function is a view function because it reads the value of the contract's balance variable, but does not modify it.


- Bonus:

    In Solidity, a modifier is a special type of function that can be used to alter the behavior of other functions in a contract. Modifiers are defined like regular functions, but they are prefixed with the modifier keyword and do not have a return type.

    Modifiers are often used to enforce certain conditions or constraints on the execution of other functions. For example, a modifier might be used to check the caller's authorization level before allowing a function to be executed, or to ensure that a function can only be called at certain times.

    Here is an example of a modifier in Solidity:

    ```solidity
    pragma solidity ^0.6.0;

    contract MyContract {
        address public owner;

        constructor() public {
            owner = msg.sender;
        }

        modifier onlyOwner() {
            require(msg.sender == owner, "Only the owner can call this function");
            _;
        }

        function setBalance(uint _balance) public onlyOwner {
            balance = _balance;
        }
    }
    ```
    In this example, the onlyOwner modifier is defined to allow only the contract owner to call the setBalance function. The require statement in the modifier checks that the caller of the function is the contract owner, and if not, it will revert the transaction with an error message. The _; statement at the end of the modifier indicates where the original function code should be inserted.

    To use a modifier, you simply add its name after the function signature, like this: function myFunction() public onlyOwner. This will insert the code from the onlyOwner modifier into the myFunction function, modifying its behavior.



<hr />
Answers are generated by OpenAI - Chat GPT.